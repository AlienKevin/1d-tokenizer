#!/usr/bin/env python3
"""
Script to create a 3x3 grid of random image samples from NPZ files generated by TiTok sampling.
Usage: python visualize_samples.py <npz_file_path>
"""

import os
import sys
import random
from PIL import Image
import argparse
import numpy as np
import torch
import demo_util


def load_npz_data(npz_path, config_path=None):
    """Load image data from NPZ file generated by TiTok sampling."""
    if not os.path.exists(npz_path):
        raise FileNotFoundError(f"NPZ file not found: {npz_path}")
    
    data = np.load(npz_path)
    print(f"Loading NPZ file: {npz_path}")
    print(f"Available keys: {list(data.keys())}")
    
    if 'arr_0' in data:
        # Decoded images case
        images = data['arr_0']  # Shape: [num_samples, H, W, C]
        conditions = data['conditions'] if 'conditions' in data else None
        print(f"Found decoded images: shape={images.shape}")
        return images, conditions, 'images'
    
    elif 'traces' in data:
        # Token traces case - need to decode using tokenizer
        traces = data['traces']  # Shape: [num_samples, num_steps, seq_len]
        conditions = data['conditions'] if 'conditions' in data else None
        print(f"Found token traces: shape={traces.shape}")
        
        if config_path is None:
            raise ValueError("Config path is required to decode token traces")
        
        # Load the tokenizer to decode tokens
        config = demo_util.get_config(config_path)
        tokenizer = demo_util.get_titok_tokenizer(config)
        
        # Use final tokens from traces (last step)
        final_tokens = traces[:, -1, :]  # Shape: [num_samples, seq_len]
        print(f"Decoding final tokens: shape={final_tokens.shape}")
        
        # Convert to tensor and decode
        final_tokens_tensor = torch.from_numpy(final_tokens).long()
        images = demo_util.decode_tokens(generated_tokens=final_tokens_tensor, tokenizer=tokenizer)
        print(f"Decoded images: shape={images.shape}")
        
        return images, conditions, 'traces'
    
    else:
        raise ValueError(f"Unsupported NPZ format. Expected 'arr_0' or 'traces', got: {list(data.keys())}")


def create_grid(image_arrays, grid_size=(3, 3)):
    """Create a grid of images from the given image arrays."""
    if len(image_arrays) < grid_size[0] * grid_size[1]:
        raise ValueError(f"Need at least {grid_size[0] * grid_size[1]} images, but only {len(image_arrays)} found")
    
    # Convert numpy arrays to PIL Images and resize
    images = []
    target_size = None
    
    for i, img_array in enumerate(image_arrays[:grid_size[0] * grid_size[1]]):
        try:
            # Handle different array formats
            if img_array.dtype == np.float32 or img_array.dtype == np.float64:
                # Normalize from [0, 1] or [-1, 1] to [0, 255]
                if img_array.min() < 0:
                    img_array = (img_array + 1) / 2  # Convert from [-1, 1] to [0, 1]
                img_array = (img_array * 255).astype(np.uint8)
            elif img_array.dtype != np.uint8:
                img_array = img_array.astype(np.uint8)
            
            # Convert to PIL Image
            img = Image.fromarray(img_array)
            if img.mode != 'RGB':
                img = img.convert('RGB')
            
            # Use the first image to determine target size
            if target_size is None:
                target_size = img.size
            else:
                # Resize to match the first image
                img = img.resize(target_size, Image.Resampling.LANCZOS)
            
            images.append(img)
        except Exception as e:
            print(f"Warning: Could not process image {i}: {e}")
            continue
    
    if len(images) < grid_size[0] * grid_size[1]:
        raise ValueError(f"Could not process enough valid images")
    
    # Create the grid
    grid_width = target_size[0] * grid_size[1]
    grid_height = target_size[1] * grid_size[0]
    grid_image = Image.new('RGB', (grid_width, grid_height), color='white')
    
    for i, img in enumerate(images[:grid_size[0] * grid_size[1]]):
        row = i // grid_size[1]
        col = i % grid_size[1]
        x = col * target_size[0]
        y = row * target_size[1]
        grid_image.paste(img, (x, y))
    
    return grid_image


def main():
    parser = argparse.ArgumentParser(description='Create a 3x3 grid of random image samples from NPZ file')
    parser.add_argument('npz_path', help='Path to the NPZ file containing images or traces')
    parser.add_argument('--output', '-o', help='Output filename (default: npz_basename.png)')
    parser.add_argument('--seed', type=int, default=3, help='Random seed for reproducible results')
    parser.add_argument('--config', help='Config file path (required for token traces)')
    
    args = parser.parse_args()
    
    npz_path = args.npz_path
    
    if not os.path.isfile(npz_path):
        print(f"Error: {npz_path} is not a valid file")
        sys.exit(1)
    
    # Set random seed if provided
    if args.seed is not None:
        random.seed(args.seed)
    
    try:
        # Load data from NPZ file
        images, conditions, data_type = load_npz_data(npz_path, args.config)
        
        if len(images) < 9:
            print(f"Error: Need at least 9 images, but only {len(images)} found in {npz_path}")
            sys.exit(1)
        
        print(f"Found {len(images)} images in {npz_path} (type: {data_type})")
        
        # Randomly select 9 images
        selected_indices = random.sample(range(len(images)), 9)
        selected_images = images[selected_indices]
        
        print(f"Selected 9 random images (indices: {selected_indices})")
        if conditions is not None:
            selected_conditions = conditions[selected_indices]
            print(f"Corresponding class labels: {selected_conditions}")
        
        # Create the grid
        grid = create_grid(selected_images)
        
        # Determine output filename
        if args.output:
            output_filename = args.output
        else:
            npz_basename = os.path.splitext(os.path.basename(npz_path))[0]
            output_filename = f"{npz_basename}_grid.png"
        
        # Save the grid
        grid.save(output_filename)
        print(f"Grid saved as: {output_filename}")
        
    except Exception as e:
        print(f"Error creating grid: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()


